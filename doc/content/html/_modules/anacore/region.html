

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>anacore.region &mdash; AnaCore  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/anacore.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> AnaCore
          

          
            
            <img src="../../_static/anacore_logo_40deg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../anacore.html">AnaCore package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AnaCore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>anacore.region</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for anacore.region</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Classes and functions for manipulating/processing regions defines on references sequences.&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Frederic Escudie&#39;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s1">&#39;Copyright (C) 2017 IUCT-O&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;GNU General Public License&#39;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;1.8.0&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;escudie.frederic@iuct-oncopole.fr&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;prod&#39;</span>


<div class="viewcode-block" id="Region"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region">[docs]</a><span class="k">class</span> <span class="nc">Region</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class to manage region on a sequence.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of Region.</span>

<span class="sd">        :param start: The start position on the reference. This position is 1-based and ascending (start &lt;= end).</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: The end position on the reference. This position is 1-based and ascending (start &lt;= end). [Default: start]</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :param strand: The strand of the instance (&quot;+&quot; or &quot;-&quot;).</span>
<span class="sd">        :type strand: str</span>
<span class="sd">        :param reference: The region object or the region name of the reference.</span>
<span class="sd">        :type reference: Region | str</span>
<span class="sd">        :param name: The name of the region.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param annot: The annotations of the region.</span>
<span class="sd">        :type annot: dict</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: region.Region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Start must be inferior to end.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setReference</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annot</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">annot</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">annot</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the “informal” or nicely printable string representation of the object.</span>

<span class="sd">        :return: The printable string representation of the object.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clean_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">clean_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clean_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clean_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clean_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clean_str</span>

<div class="viewcode-block" id="Region.getCoordinatesStr"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.getCoordinatesStr">[docs]</a>    <span class="k">def</span> <span class="nf">getCoordinatesStr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return printable string representation of the coordinates.</span>

<span class="sd">        :return: The printable representation of the coordinates.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strand</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Region.length"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return length of the region.</span>

<span class="sd">        :return: The length of the region.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Region.setReference"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.setReference">[docs]</a>    <span class="k">def</span> <span class="nf">setReference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the reference region of the instance.</span>

<span class="sd">        :param reference: The region object or the region name of the reference.</span>
<span class="sd">        :type regreferenceion_pos: region.Region | str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">Region</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Region</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; is not authorized for reference attribute in Region class.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Region.getPosOnRef"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.getPosOnRef">[docs]</a>    <span class="k">def</span> <span class="nf">getPosOnRef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return coordinate on reference sequence from the coordinate on self.</span>

<span class="sd">        :param region_pos: Coordinate on region (1-based).</span>
<span class="sd">        :type region_pos: int.</span>
<span class="sd">        :return: The coordinate on reference sequence (1-based).</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot return a reference position from the region position because the strand is None in </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span>
            <span class="p">))</span>
        <span class="n">reference_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">reference_pos</span> <span class="o">=</span> <span class="n">region_pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reference_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">region_pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">reference_pos</span></div>

<div class="viewcode-block" id="Region.getPosOnRegion"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.getPosOnRegion">[docs]</a>    <span class="k">def</span> <span class="nf">getPosOnRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return coordinate on region from the coordinate on reference sequence.</span>

<span class="sd">        :param ref_pos: The coordinate on reference sequence (1-based).</span>
<span class="sd">        :type ref_pos: int</span>
<span class="sd">        :return: Coordinate on region (1-based).</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot return a region position from the reference position because the strand is None in </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="p">))</span>
        <span class="k">if</span> <span class="n">ref_pos</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="n">ref_pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The region </span><span class="si">{}</span><span class="s2"> does not contains the position </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">ref_pos</span>
            <span class="p">))</span>
        <span class="n">region_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="n">region_pos</span> <span class="o">=</span> <span class="n">ref_pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">ref_pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">region_pos</span></div>

<div class="viewcode-block" id="Region.contains"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the region contains the eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: True if the region contains the evaluated region.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contains</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">start</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">contains</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">contains</span></div>

<div class="viewcode-block" id="Region.strandedContains"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.strandedContains">[docs]</a>    <span class="k">def</span> <span class="nf">strandedContains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the region contains the eval_region and their are on the same strand.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: True if the region contains the evaluated region.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contains</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">strand</span><span class="p">:</span>
            <span class="n">contains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">eval_region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contains</span></div>

<div class="viewcode-block" id="Region.hasOverlap"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.hasOverlap">[docs]</a>    <span class="k">def</span> <span class="nf">hasOverlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the region has an overlap with eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: True if the region has an overlap with evaluated region.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_overlap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">end</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="n">has_overlap</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">has_overlap</span></div>

<div class="viewcode-block" id="Region.hasStrandedOverlap"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.hasStrandedOverlap">[docs]</a>    <span class="k">def</span> <span class="nf">hasStrandedOverlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the region has an overlap with eval_region and their are on the same strand.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: True if the region has an overlap with evaluated region.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_overlap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">strand</span><span class="p">:</span>
            <span class="n">has_overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasOverlap</span><span class="p">(</span><span class="n">eval_region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_overlap</span></div>

<div class="viewcode-block" id="Region.getMinDist"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.getMinDist">[docs]</a>    <span class="k">def</span> <span class="nf">getMinDist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the distance with the eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: The distance between the instance and the evaluated region.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The minimal distance between regions cannot be processed because their are located on diffrents reference (&quot;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot; vs &quot;&#39;</span> <span class="o">+</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;).&#39;</span><span class="p">)</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasOverlap</span><span class="p">(</span><span class="n">eval_region</span><span class="p">):</span>  <span class="c1"># Eval region overlaps region</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>  <span class="c1"># Eval region is located before region</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">end</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Eval region is located after region</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span>
        <span class="k">return</span> <span class="n">min_dist</span></div>

<div class="viewcode-block" id="Region.fromStr"><a class="viewcode-back" href="../../anacore.html#anacore.region.Region.fromStr">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fromStr</span><span class="p">(</span><span class="n">interval_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return region instance from interval string (example: 5:15746211-5746311).</span>

<span class="sd">        :param interval_str: interval string in format &lt;ref_name&gt;:&lt;start_pos&gt;-&lt;end_pos&gt;. Positions are 1-based.</span>
<span class="sd">        :type interval_str: str</span>
<span class="sd">        :return: Region instance from interval string.</span>
<span class="sd">        :rtype: anacore.region.Region</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference</span><span class="p">,</span> <span class="n">start_end</span> <span class="o">=</span> <span class="n">interval_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start_end</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Region</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RegionTree"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionTree">[docs]</a><span class="k">class</span> <span class="nc">RegionTree</span><span class="p">(</span><span class="n">Region</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to manage region with hierarchical relations (example: gene -&gt; transcript -&gt; exons).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of RegionTree.</span>

<span class="sd">        :param start: The start position on the reference. This position is 1-based and ascending (start &lt;= end).</span>
<span class="sd">        :type start: int</span>
<span class="sd">        :param end: The end position on the reference. This position is 1-based and ascending (start &lt;= end). [Default: start]</span>
<span class="sd">        :type end: int</span>
<span class="sd">        :param strand: The strand of the instance (&quot;+&quot; or &quot;-&quot;).</span>
<span class="sd">        :type strand: str</span>
<span class="sd">        :param reference: The region object or the region name of the reference.</span>
<span class="sd">        :type reference: region.Region | str</span>
<span class="sd">        :param name: The name of the region.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param annot: The annotations of the region.</span>
<span class="sd">        :type annot: dict</span>
<span class="sd">        :param parent: The parent region (example: gene for a transcript).</span>
<span class="sd">        :type parent: region.RegionTree</span>
<span class="sd">        :param children: The list of sub-regions (example: exons in transcript).</span>
<span class="sd">        :type children: region.RegionList</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: region.RegionTree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">()</span>
        <span class="n">Region</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">annot</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the “informal” or nicely printable string representation of the object.</span>

<span class="sd">        :return: The printable string representation of the object.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clean_str</span> <span class="o">=</span> <span class="n">Region</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">clean_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> [</span><span class="si">{}</span><span class="s2"> children]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clean_str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;feature&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;feature&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clean_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;feature&quot;</span><span class="p">],</span> <span class="n">clean_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clean_str</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of the selected attribute.</span>

<span class="sd">        :param name: The name of the selected attribute.</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: The value of the attribute.</span>
<span class="sd">        :rtype: *</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">child</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">child</span><span class="o">.</span><span class="n">end</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;strand&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strand</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;reference&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reference</span>
        <span class="k">return</span> <span class="n">value</span>

<div class="viewcode-block" id="RegionTree.addChild"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionTree.addChild">[docs]</a>    <span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add child region in region.</span>

<span class="sd">        :param child: The added region.</span>
<span class="sd">        :type child: region.RegionTree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check compatibility</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">!=</span> <span class="n">child</span><span class="o">.</span><span class="n">strand</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sub-region </span><span class="si">{}</span><span class="s2"> cannot be added to </span><span class="si">{}</span><span class="s2"> because their strands are different.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">child</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sub-region </span><span class="si">{}</span><span class="s2"> cannot be added to </span><span class="si">{}</span><span class="s2"> because their reference region are different.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="c1"># Process</span>
        <span class="n">child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sortChildren</span><span class="p">()</span></div>

<div class="viewcode-block" id="RegionTree.sortChildren"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionTree.sortChildren">[docs]</a>    <span class="k">def</span> <span class="nf">sortChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort children in order of their apparition on self strand. Add siblings_idx (1-based) in annotations of children.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot sort sub-regions because the strand is None in </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># Sort</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">)))</span>
        <span class="c1"># Add siblings_idx</span>
        <span class="k">for</span> <span class="n">siblings_idx</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">child</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;siblings_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">siblings_idx</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Siblings idx is 1-based</span></div></div>


<div class="viewcode-block" id="RegionList"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionList">[docs]</a><span class="k">class</span> <span class="nc">RegionList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to manage regions list. for example all the gene on a chromosome.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return an instance of RegionList.</span>

<span class="sd">        :param regions: List of regions.</span>
<span class="sd">        :type regions: list</span>
<span class="sd">        :return: The new instance.</span>
<span class="sd">        :rtype: region.RegionList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>

<div class="viewcode-block" id="RegionList.getContainers"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionList.getContainers">[docs]</a>    <span class="k">def</span> <span class="nf">getContainers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all the regions that contains the eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: Regions containing the evaluated region.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">eval_region</span><span class="p">):</span>
                <span class="n">containers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">containers</span></div>

<div class="viewcode-block" id="RegionList.getOverlapped"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionList.getOverlapped">[docs]</a>    <span class="k">def</span> <span class="nf">getOverlapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all the regions that have an overlap with eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: Regions having an overlap with evaluated region.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">hasOverlap</span><span class="p">(</span><span class="n">eval_region</span><span class="p">):</span>
                <span class="n">overlapped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">overlapped</span></div>

<div class="viewcode-block" id="RegionList.getNearests"><a class="viewcode-back" href="../../anacore.html#anacore.region.RegionList.getNearests">[docs]</a>    <span class="k">def</span> <span class="nf">getNearests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_region</span><span class="p">,</span> <span class="n">select_fct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nearest region to eval_region.</span>

<span class="sd">        :param eval_region: The evaluated region.</span>
<span class="sd">        :type eval_region: Region</span>
<span class="sd">        :return: The distance between the nearest region and self.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nearests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">min_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">select_fct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="n">select_fct</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">selected</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">eval_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">curr_dist</span> <span class="o">=</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">getMinDist</span><span class="p">(</span><span class="n">eval_region</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">min_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr_dist</span> <span class="o">&lt;=</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">min_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr_dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                            <span class="n">nearests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">curr_dist</span>
                        <span class="n">nearests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">nearests</span></div></div>


<div class="viewcode-block" id="splittedByRef"><a class="viewcode-back" href="../../anacore.html#anacore.region.splittedByRef">[docs]</a><span class="k">def</span> <span class="nf">splittedByRef</span><span class="p">(</span><span class="n">region_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return regions list by reference.</span>

<span class="sd">    :param region_list: The list of regions.</span>
<span class="sd">    :type region_list: RegionList</span>
<span class="sd">    :return: Regions list by reference.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">regions_by_ref</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="n">region_list</span><span class="p">:</span>
        <span class="n">ref_name</span> <span class="o">=</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">regions_by_ref</span><span class="p">:</span>
            <span class="n">regions_by_ref</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">()</span>
        <span class="n">regions_by_ref</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">regions_by_ref</span></div>


<div class="viewcode-block" id="mergedRegion"><a class="viewcode-back" href="../../anacore.html#anacore.region.mergedRegion">[docs]</a><span class="k">def</span> <span class="nf">mergedRegion</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a region corresponding to the merge of all provided regions.</span>

<span class="sd">    :param regions: One list of overlapped regions.</span>
<span class="sd">    :param type: list</span>
<span class="sd">    :param trace: if true the provided regions are store in merged_region.annot[&quot;merge_traceback&quot;].</span>
<span class="sd">    :type trace: bool</span>
<span class="sd">    :return: The region corresponding to the merge of all provided regions.</span>
<span class="sd">    :rtype: Region</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check reference</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_region</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;All the regions in mergedRegion are not defined on the same reference.&quot;</span><span class="p">)</span>
    <span class="c1"># Init merged region</span>
    <span class="n">merged_region</span> <span class="o">=</span> <span class="n">Region</span><span class="p">(</span>
        <span class="nb">min</span><span class="p">([</span><span class="n">curr</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]),</span>
        <span class="nb">max</span><span class="p">([</span><span class="n">curr</span><span class="o">.</span><span class="n">end</span> <span class="k">for</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]),</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reference</span><span class="p">,</span>
        <span class="kc">None</span>
    <span class="p">)</span>
    <span class="c1"># Strand</span>
    <span class="n">strands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">curr</span><span class="o">.</span><span class="n">strand</span> <span class="k">for</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">merged_region</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Traceback</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">merged_region</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;merge_traceback&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;merge_traceback&quot;</span> <span class="ow">in</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">annot</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">curr_trace</span> <span class="ow">in</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;merge_traceback&quot;</span><span class="p">]:</span>
                    <span class="n">merged_region</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;merge_traceback&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_trace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_region</span><span class="o">.</span><span class="n">annot</span><span class="p">[</span><span class="s2">&quot;merge_traceback&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_region</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merged_region</span></div>


<div class="viewcode-block" id="consolidated"><a class="viewcode-back" href="../../anacore.html#anacore.region.consolidated">[docs]</a><span class="k">def</span> <span class="nf">consolidated</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">merge_contiguous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return consolidated regions: the overlapping regions (and optionally the contiguous) are merged in one region.</span>

<span class="sd">    :param regions: List of regions to consolidate.</span>
<span class="sd">    :param type: list</span>
<span class="sd">    :param merge_contiguous: If true the contiguous regions are also merged.</span>
<span class="sd">    :type merge_contiguous: bool</span>
<span class="sd">    :param trace: if true the provided regions are store in merged_region.annot[&quot;merge_traceback&quot;].</span>
<span class="sd">    :type trace: bool</span>
<span class="sd">    :return: Consolidated regions.</span>
<span class="sd">    :rtype: RegionList</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">merge_contiguous</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">merged_regions</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">()</span>
    <span class="n">regions_by_ref</span> <span class="o">=</span> <span class="n">splittedByRef</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ref_id</span><span class="p">,</span> <span class="n">ref_regions</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">regions_by_ref</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">sorted_regions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ref_regions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
        <span class="n">prev_region</span> <span class="o">=</span> <span class="n">sorted_regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">curr_region</span> <span class="ow">in</span> <span class="n">sorted_regions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">curr_region</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">prev_region</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="n">padding</span><span class="p">:</span>
                <span class="n">prev_region</span> <span class="o">=</span> <span class="n">mergedRegion</span><span class="p">([</span><span class="n">prev_region</span><span class="p">,</span> <span class="n">curr_region</span><span class="p">],</span> <span class="n">trace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_region</span><span class="p">)</span>
                <span class="n">prev_region</span> <span class="o">=</span> <span class="n">curr_region</span>
        <span class="n">merged_regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_region</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merged_regions</span></div>


<div class="viewcode-block" id="iterOverlapped"><a class="viewcode-back" href="../../anacore.html#anacore.region.iterOverlapped">[docs]</a><span class="k">def</span> <span class="nf">iterOverlapped</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">check_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a generator on query and his overlapped subjects. For example you can provide a list of variant (queries) and search the genes overlapped by each variant in the list of genes (subjects).</span>

<span class="sd">    :param queries: The queries. They must be defined on the same reference.</span>
<span class="sd">    :type queries: list</span>
<span class="sd">    :param subjects: The regions where the overlap is searched. They must be defined on the same reference.</span>
<span class="sd">    :type subjects: list</span>
<span class="sd">    :param check_ref: If True all the queries and subjects are checked to ensure they care defined on the same reference. Use False to gain computation time if you are certain that all elements are defined on the same reference.</span>
<span class="sd">    :type check_ref: bool</span>
<span class="sd">    :return: Each iteration return one query and the list of subjects overlapped by it. The queries are ordered by ascending coordinates.</span>
<span class="sd">    :rtype: A generator on couple (Region, RegionList)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">check_ref</span><span class="p">:</span>
        <span class="n">references</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">subjects</span> <span class="o">+</span> <span class="n">queries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elt</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">references</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">references</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;All the queries and subjects in iterOverlapped are not defined on the same reference.&quot;</span><span class="p">)</span>
    <span class="n">subjects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">subjects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
    <span class="n">queries</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
    <span class="n">subject_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nb_subjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subjects</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">curr_query</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="c1"># Find overlapping transcripts</span>
        <span class="k">while</span> <span class="n">subject_idx</span> <span class="o">&lt;</span> <span class="n">nb_subjects</span> <span class="ow">and</span> <span class="n">curr_query</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">subjects</span><span class="p">[</span><span class="n">subject_idx</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="n">subject_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">first_subject_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">overlapping_subjects</span> <span class="o">=</span> <span class="n">RegionList</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">subject_idx</span> <span class="o">&lt;</span> <span class="n">nb_subjects</span> <span class="ow">and</span> <span class="n">curr_query</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">subjects</span><span class="p">[</span><span class="n">subject_idx</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="n">curr_subject</span> <span class="o">=</span> <span class="n">subjects</span><span class="p">[</span><span class="n">subject_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_query</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">curr_subject</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="n">overlapping_subjects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_subject</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">first_subject_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">first_subject_idx</span> <span class="o">=</span> <span class="n">subject_idx</span>
            <span class="n">subject_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">subject_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">subject_idx</span> <span class="k">if</span> <span class="n">first_subject_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">first_subject_idx</span><span class="p">)</span>  <span class="c1"># Return to the first subject overlapping the query</span>
        <span class="c1"># Return current query and his overlaps</span>
        <span class="k">yield</span><span class="p">(</span><span class="n">curr_query</span><span class="p">,</span> <span class="n">overlapping_subjects</span><span class="p">)</span></div>


<div class="viewcode-block" id="iterOverlappedByRegion"><a class="viewcode-back" href="../../anacore.html#anacore.region.iterOverlappedByRegion">[docs]</a><span class="k">def</span> <span class="nf">iterOverlappedByRegion</span><span class="p">(</span><span class="n">queries_by_chr</span><span class="p">,</span> <span class="n">subject_by_chr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a generator on query and his overlapped subjects. For example you can provide a list of variant (queries) and search the genes overlapped by each variant in the list of genes (subjects).</span>

<span class="sd">    :param queries_by_chr: By chromosome the queries.</span>
<span class="sd">    :type queries_by_chr: dict</span>
<span class="sd">    :param subject_by_chr: By chromosome the regions where the overlap is searched.</span>
<span class="sd">    :type subject_by_chr: dict</span>
<span class="sd">    :return: Each iteration return the chromosome name, one query and the list of subjects overlapped by it. The queries are ordered by ascending coordinates.</span>
<span class="sd">    :rtype: A generator on couple (str, Region, RegionList)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">queries_by_chr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subject_by_chr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">queries_by_chr</span><span class="p">[</span><span class="n">chrom</span><span class="p">]:</span>
                <span class="k">yield</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">RegionList</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">query</span><span class="p">,</span> <span class="n">overlapping_subjects</span> <span class="ow">in</span> <span class="n">iterOverlapped</span><span class="p">(</span><span class="n">queries_by_chr</span><span class="p">[</span><span class="n">chrom</span><span class="p">],</span> <span class="n">subject_by_chr</span><span class="p">[</span><span class="n">chrom</span><span class="p">],</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">yield</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">overlapping_subjects</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Frédéric Escudié.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>